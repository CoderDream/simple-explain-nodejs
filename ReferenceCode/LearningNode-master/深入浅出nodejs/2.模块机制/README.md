# 第二章模块机制
## CommonJS
### CommonJS的规范
1. 模块引用
```
const math = require('math');
```
CommonJS中使用require来导入模块
2. 模块导出
```
export.add = function () {
    return argument.reduce((total, item) => (total + item), 0);
}
```
在模块中还存在一个module对象，它表示模块自身，而exports是module的属性。在Node中一个文件就是一个模块，将方法挂载在 exports对象上作为属性即可定义导出的方式。
3. 模块标识
模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径。它可以没有文件名后缀.js。并且CommonJS构建的这套模块导出和引入机制使得用户完全不必考虑变量污染。
### Node的模块实现
在Node中引入模块，需要经历如下3个步骤
1. 路径分析
2. 文件定位
3. 编译执行

在Node中，模块分为两类：一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。

- 核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以他的加载速度是最快的
- 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢
#### 优先从缓存加载
与前端浏览器会缓存静态脚本文件以提高性能一样，Node对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而Node缓存的是编译和执行之后的对象。

不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查咸鱼文件模块的缓存检查。
#### 路径分析和文件定位
因为标识符有几种形式，对于不同的标识符，模块的查找和定位有不同程度上的差异
1. 模块标识符分析

模块标识符主要分为核心模块（如http、fs、path等）、相对路径模块（.或..开始的模块）、绝对路径模块（/开始的模块）、非路径形式的文件模块（如自定义的connect）

- 核心模块

优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译成为了二进制代码，其加载过程最快。

如果想要加载一个和核心模块名字一样的自定义模块，那是不会成功的，因为核心模块的优先级是高于文件模块的。

- 路径形式的文件模块

在分析文件模块时，require()方法会将路径转化为真实路径，并以真实路径为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。

因为文件模块给Node指明了确切的文件位置，所以在查找的过程中可以节省大量时间，其加载速度慢于核心模块。

- 自定义模块

自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找也是最费时的，也是所有方式中最慢的一种。

我们可以进行尝试一下

模块路径这个概念指的是在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。关于这个路径的规则，我们可以手动尝试一番（具体代码查看path.js）

运行path.js然后你发现打印出来一个路径数组

所以可以看出，模块路径的生成规则

当前文件目录下的node_module

父级目录下的node_module

父级的父级目录下的node_module

沿路径向上逐级递归，直到根目录下的node_module

在加载的过程中，node会逐个尝试模块路径中的路径，直到找到目标文件为止。可以看出，当前文件的路径越深，模块查找的耗时会越多，这是自定义模块加载速度最慢的原因。

2. 文件定位
从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了了再次加载模块时的效率

但在文件的定位过程中，还有一些细节需要注意，这主要包括文件扩展名的分析、目录和包的处理。

- 文件扩展名分析

require()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范也允许在标识符中不包含文件扩展名，这种情况下，Node会按照.js、.json、.node的次序补足扩展名，依次尝试。

在尝试的过程中，需要调用fs模块同步阻塞式地判断文件是否存在。因为Node是单线程的，所以这里是一个会引起性能问题的地方。小诀窍是：如果是.node和.json文件，在传递给require()的标识符中带上扩展名，会加快一点速度。另一个诀窍是：同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷。

- 目录分析和包

在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件啊，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时会经常出现，此时Node会将目录当做一个包来处理。

在这个过程中，Node对CommonJS包规范进行了一定程度的支持。首先，Node在当前目录下查找package.json(CommondJs包规范定义的包描述文件)，通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件缺少扩展名，将会进入扩展名分析的步骤。

如果main属性指定的文件名错误，或者没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js、index.json、index.node。

如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有找到目标文件，则会抛出查找失败的异常。
#### 模块编译
在Node中，每个文件模块都是一个对象，他的定义见module.js

编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有不同，具体如下所示。

- .js文件。通过fs模块同步读取文件后编译执行。
- .node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加在最后编译生成的文件。
- .json文件。通过fs模块同步读取文件之后，用JSON.parse()解析返回结果。
- 其余扩展名文件。它们都被当做.js文件载入。

每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。

根据不同的文件扩展名，Node会调用不同的读取方式，如.json文件的调用方式见read-json.js

其中，Module._extensions会被赋值给require()的extensions属性，所以通过在代码中访问require.extensions可以知道系统中已有的扩展加载方式。可以运行see-load.js

可以得到执行结果`{ '.js': [Function], '.json': [Function], '.node': [Function] }`

如果想对自定义扩展名进行特殊的加载，可以通过类似`require.extensions['.ext']`的方式实现。早期的CoffeeScript文件就是通过`require.extensions['.coffee']`扩展的方式来实现加载的。但是从v0.10.6版本开始，官方不鼓励通过这种方式来自定义扩展名的加载，而是期望先将其他语言转换为js文件后再加载。

1. JavaScript模块的编译
在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了(function (exports, require, module, __filename, __dirname) {\n, 在尾部添加了\n});。

一个正常的JavaScript文件会被包装成area.js的样子，这样每个模块文件之间都进行了作用域隔离。包装之后的代码会通过vm原生模块的runInThisContext()方法执行（类似于eval，只是具有明确上下文，不污染全局），返回一个具体的function对象。最后将让当前模块对象的exports属性、require()方法、module(模块对象自身),以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。

这就是这些变量并没有定义在每个模块文件中却存在的原因。在执行之后，模块的exports属性被返回给了调用方。exports属性上的任何方法都可以被外部调用到，但是模块中的其余变量或属性则不可直接被调用。

此外，许多初学者都曾经纠结过为何存在exports的情况下，还存在module.exports。理想情况下，只要给exports赋值即可。
```
exports = function () {
    // my class
}
```
但是上面的代码通常就会得到一个失败的结果。通过area.js的代码我们可以知道，exports对象是通过形参的方式传入的，直接赋值形参会改变形参的引用，但不能改变作用域外的值。所以结论是如果你要给exports直接赋值请使用module.exports。如果你只是想给exports添加属性，则只需要使用exports即可。

2. C/C++模块的编译

Node调用process.dlopen()方法进行加载和执行。在Node的架构下，dlopen()方法在Windows和*nix平台下分别有不同的实现， 通过libuv兼容层进行了封装。

实际上，.node的模块文件不需要编译，因为他是C/C++编译之后编译生成的，所以这里只有加载和执行的过程。在执行的过程中，模块的exports对象与.node模块产生联系，然后返回给调用者。

3. .json文件的编译
.json文件的编译是3种编译方式里最简单的。Node利用fs模块同步读取JSON文件的内容之后，调用JSON.parse()方法得到对象，然后将它赋给模块对象的exports，以供外部使用。

如果你想读取JSON文件，不需要调用fs模块去异步读取和解析，直接调用require()引入即可，并且，还可以享受缓存的便利，并且二次引入也没有性能影响

### 包与npm
#### 包结构
包实际上是一个存档文件，即一个目录直接打包为.zip或tar.gz格式的文件，安装后解压还原为目录。完全符合CommonJS规范的包目录应该包含如下这些文件。
- package.json：包描述文件
- bin: 用于存放可执行二进制文件的目录
- lib: 用于存放Javascript代码的目录
- doc: 用于存放文档的目录
- test: 用于存放单元测试用例的代码
#### 包描述文件和NPM
CommonJS为package.json文件定义了如下一些必须的字段
- name: 包名。规范定义它需要由小写的字母和数字组成，可以包含.、-和_，但不允许出现空格。包名必须是唯一的，以免对外公布时产生重名冲突的误解。除此之外，NPM还建议不要在包名中附带上node或者js来重复表示他是JS或者Node模块
- descriptoion: 包介绍。
- version: 版本号。一个语义化的版本号。
- keywords: 关键字数组，NPM主要用来做分类搜索。一个好的关键词数组有利于用户快速找到你编写的包。
- maintainers: 包维护者列表。每个维护者由name、email和web这三个属性组成。NPM通过该属性进行权限认证。
- contributors: 贡献者列表。它的格式与维护者列表相同。
- bugs: 一个可以反馈bug的网页地址或邮件地址。
- licenses: 当前包所使用的许可证列表，表示这个包可以在哪些许可证下使用。
- repositories: 托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源代码。
- dependencies: 使用当前包所需要依赖的包列表。这个属性非常重要，NPM会通过这个属性帮助自动加载依赖的包。
- homepage: 当前包的网络地址
- os: 操作系统的支持列表。
- cpu: cpu架构的支持列表
- engine: 支持JavaScript引擎列表，有效的引擎取值包括ejs、flusspferd、gpsee、jsc、spidermonkey、narwhal、node、v8
- builtin: 标志当前包是否是内建在底层系统的标准组件。
- directories: 包目录说明
- implements: 实现规范的列表。标志当前包实现了CommonJS的那些规范
- srcipt: 脚本说明对象。它主要被包管理器用来安装、编译、测试、和卸载包。
- author: 包作者
- bin: 一些包作者希望可以作为命令行工具使用。配置好bin字段后,通过npm install [packageName] -g命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行。
- main: 模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口。如果不存在这个字段，会依次查找index.js、index.node、index.json作为默认入口文件
#### NPM常用功能
直接执行npm可以查看帮助引导说明
1. 全局安装

执行npm install [packagename] -g就能全局安装。需要注意的是，全局安装并不是将一个模块安装为一个全局包的意思，它并不意味着可以从任何地方通过require()来引用到它。

全局模式这个称谓其实并不精确，存在诸多误导。实际上，-g是将一个包安装为全局可用的可执行命令。他根据文件中bin字段配置，将实际脚本链接到Node可执行文件相同的路径下

事实上，通过全局模式安装的所有模块包都被安装进了一个统一的目录下这个目录可以通过get-lib.js推算出来

2. 从本地安装

对于一些没有发布到NPM上的包，或是因为网络原因导致无法直接安装的包，可以通过将包下载到本地，然后以本地安装。本地安装只需为NPM指明package.json文件所在位的位置即可：它可以是一个包含package.json的存档文件，也可以是一个URL地址，也可以是一个目录下有package.json文件的目录位置。具体参数如下：
- npm install [tarball file]
- npm install [tarball url]
- npm install [folder]

3. 从非官方源安装
有三种方法
- 添加--registry=http://registry.url 即可，如：npm i [package] --registry=http://registry.url
- 使用npm config set registry http://registry.url 指定默认源
- 使用nrm进行源管理
##### 发布包
1. 编写模块

编写好你的代码并且导出相应的模块

2. 初始化包描述文件

运行npm init指令

3. 注册包仓库账号

运行 npm adduser

4. 上传包

运行npm public <folder> 在这个过程中，npm会将目录打包为一个存档文件，然后上传到官方源仓库中。

5. 管理包权限

通过npm owner <指令> 来管理包的权限
##### 分析包
可以通过npm ls来分析出当前路径下能够通过模块路径找到的所有包，并且生成依赖树。
#### 局域NPM
如果想同时能够享受到NPM上众多的包，同时对自己的包进行保密和限制，现有的解决方案就是搭建自己的NPM仓库

详情见附录D（现在还没有以后会完善）
### 前后端公用模块
这里主要讲了AMD规范和CMD规范，到现在已经很少用了，所以我也只是看看，并不做记录。