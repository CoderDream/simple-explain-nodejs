# 第三章异步I/O
## 为什么要异步I/O
### 用户体验
异步的概念之所以火起来，是因为在浏览器中JavaScript在单线程上执行，而且它还与UI渲染公用一个线程。

如果不使用异步,而采用同步代码的话
```
// 消费时间为M
getData('form_db');
// 消费时间为N
getData('form_remote_api');
```
消耗时间为M+N
```

getData('form_db', function() {
    // 消费时间为M  
});
getData('form_remote_api', function() {
    // 消费时间为N
});
```
消耗时间为Max(M, N),因为JS脚本执行变快，异步I/O会大大提升用户的体验
### 资源分配
如果业务场景中有一组互不相关的任务需要完成，现行的主流方式有2种
1. 单线程串行依次执行
2. 多线程并行完成

如果创建多线程的开销小于并行执行，那么多线程的方式是首选的。多线程的代价在于创建线程和执行期线程上下文切换的开销较大。另外，在复杂的业务中，多线程编程经常面临锁、状态同步等问题，这是多线程被诟病的主要原因。但是多线程在多核CPU上能够有效提升CPU的利用率，这个优势是毋庸置疑的。

单线程顺序执行任务的方式比较符合编程人员按顺序思考的思维方式。它依然是最主流的编程方式，因为它易于表达。但是串行执行的缺点在于性能，任意一个略慢的任务都会导致后续执行代码被阻塞。在计算机资源中，通常I/O的进行会让后续任务等待，这造成资源不能被很好地利用。

操作系统会将CPU的时间片分配给其余进程，以公平而有效地利用资源，基于这一点，有的服务器为了提升响应能力，会通过启动多个工作进程来为更多的用户服务。但是对于这一组任务而言，他无法分发任务到多个进程上，所以依然无法高效利用资源，结束所有任务所需的时间会较长。这种模式类似于加三倍服务器。

单线程同步编程模型会因阻塞I/O导致硬件资源得不到更优的使用。多线程编程模型也因为编程中的死锁、状态同步等问题让开发人员头疼。

Node在两者之间给出了它的方案：利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O，让单线程远离阻塞，以更好地使用CPU。

异步I/O的提出是期望I/O的调用不再阻塞后续运算，将原有等待I/O完成的这段时间分配给其余需要的业务执行。
## 异步I/O是实现现状
### 异步I/O与非阻塞I/O
操作系统内核对于I/O只有两种方式: 阻塞和非阻塞。在调用阻塞I/O时，应用程序需要等待I/O完成才返回结果

阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分的利用。为了提高性能，内核提供了非阻塞I/O。非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回。

操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件I/O操作时，通过文件描述符进行管理，而文件描述符类似于应用程序与系统内核之间的凭证。应用程序如果需要进行I/O调用，需要先打开文件描述符，然后再根据文件描述符去实现文件的数据读写。此处非阻塞I/O的区别和阻塞I/O的区别在于阻塞I/O完成整个获取数据的过程，而非阻塞I/O不带数据直接返回，要获取数据，还需要通过文件描述符再次读取。

非阻塞I/O返回之后，CPU的时间片可以用来处理其他事物，此时的性能提升是明显的。

但非阻塞I/O也存在一些问题。由于完整的I/O并没有完成，立即返回的并不是业务层期望的数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。这种重复调用判断是否完成的技术叫做轮询。

任何技术都并非完美的。阻塞I/O造成CPU等待浪费，非阻塞带来的麻烦确实需要轮询确认是否完全完成数据获取，它会让CPU处理状态判断，是对CPU资源的浪费。这里我们来看轮询技术是如何演进的，以减小I/O状态判断的CPU损耗。

现存的轮询技术主要有以下这些

1. read。它是最原始、性能最低的一种，通过重复调用来检查I/O的状态来完成完整数据的读取。在得到最终数据前，CPU一直耗用在等待上。
2. select。它是在read的基础上改进的一种方案，通过对文件描述符上事件状态来进行判断。但是select轮询具有一个较弱的限制，那就是由于它采用一个1024长度的数组来储存状态，所以它最多可以同时检查1024个文件描述符。
3. poll。该方案较select有所改进，采用链表的方式避免数组长度的限制，其次它能避免不需要的检查。但是当文件描述符较多的时候，它的性能还是十分低下的。
4. epoll。该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高。
5. kqeue。该方案的实现方式与epoll类似，不过它仅在FreeBSD系统下存在。

轮询技术满足了非阻塞I/O确保获取完整数据的需求，但是对于应用程序而言，它仍然只能算是一种同步，因为应用程序任然需要等待I/O完全返回，依旧花费了很多时间来等待。等待时间，CPU要么用于遍历文件描述符的状态，要么用于休眠等待事件发生。
### 理想的非阻塞异步I/O
尽管epoll已经利用了事件来降低CPU的耗用，但是休眠期间CPU几乎是闲置的，对于当前线程而言利用率不够。

我们希望的完美异步I/O应该是应用程序发起非阻塞调用，无须通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需在I/O完成后通过信号或回调将数据传递给应用程序即可。

幸运的是，在linux下存在这样一种方法，它原生提供的一种异步I/O方式（AIO）就是通过信号或回调来传递数据的。

但不幸的是，只有Linux下有，而且它还有缺陷 —— AIO仅支持内核I/O中的O_DIRECT方式读取，导致无法利用系统缓存
### 现实的异步I/O
前面我们将场景限定在了单线程的情况下，多线程的方式就会是另一种情况了。通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递，这样就轻松实现了异步I/O。

glibc的AIO便是典型的线程池模拟异步I/O。然而遗憾的是，它存在一些难以忍受的缺陷和bug，不推荐采用。libev的作者重新实现了一个异步I/O的库：libeio。libeio实质上依然是采用线程池与阻塞I/O模拟异步I/O。最初，Node在*nix平台下采用libeio配合libev实现I/O部分，实现了异步I/O。在Node v0.93中，自行实现了线程池来完成异步I/O

另一种异步方案则是windows下的IOCP，它在某种程度上提供了理想的异步I/O：调用异步方法，等待I/O完成之后的通知，执行回调，用户无须考虑轮询。但是它的内部其实仍然是线程池原理，不同之处在于这些线程池由系统内核接手管理。

IOCP的异步I/O模型与Node的异步调用模型十分近似。在Windows平台下采用了IOCP实现异步I/O。

由于Windows平台和*nix平台的差异，Node提供了libuv作为抽象封装层，使得所有平台兼容性的判断都由这一层来完成，并保证上层的Node与下层的自定义线程池及IOCP之间各自独立。Node在编译期间会判断平台条件，选择性编译unix目录或是win目录下的源文件到目标程序中。

需要强调一点的是，这里的I/O不仅仅只限于磁盘文件的读写。*unix将计算机抽象了一番，磁盘文件、硬件、套接字等几乎所有计算机资源都被抽象成了文件，因此这里描述的阻塞和非阻塞的情况同样能适合于套接字等。

另一个需要强调的地方在于我们时常提到Node是单线程的，这里的单线程仅仅只是JavaScript执行在单线程中罢了。在Node中，无论是*unix还是Windows平台，内部完成I/O任务的另有线程池。
## Node的异步I/O
### 事件循环
首先，我们先强调一下Node自身的执行模型————事件循环，正是它使得回调函数十分普遍。

在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。
### 观察者
每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。

浏览器采用了类似的机制。事件可能来自用户的点击或者加载某些文件时产生，而这些产生的事件都有对应的观察者。在Node中，事件主要来源于网络请求、文件I/O等，这些事件对应的观察者有文件I/O观察者、网络I/O观察者等。观察者将事件进行了分类。

事件循环是一个典型的生产者/消费者模型。异步I/O、网络请求等则是事件的生产者，源源不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。

在Windows下，这个循环基于IOCP创建，而在*nix下则基于多线程创建。
### 请求对象
我们通过解释Windows下异步I/O(利用ICOP)的简单例子来探寻从JavaScript代码到系统内核之间都发生了什么。

对于一般的(非异步)回调函数，函数由我们自行调用，如下
```
var forEach = function (list, callback) {
    for (var i = 0; i < list.length; i++) {
        callback(list[i], i, list);
    }
}
```
对于Node中的异步I/O调用而言，回调函数却不由开发者来调用。从JavaScript发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，它叫做请求对象。

下面我们以最简单的fs.open()方法作为例子，探索Node与底层之间是如何执行异步I/O调用以及回调函数究竟是如何被调用执行的
```
fs.open = function(path, flags, mode, callback) {
    // ...
    binding.open(pathModule._makeLong(path), stringToFlags(flags), mode, callback);
}
```
fs.open()的作用是根据指定路径和参数去打开一个文件，从而得到一个文件描述符，这是后续所有I/O操作的初始操作。从前面的代码我们可以看到，JavaScript层面的代码通过调用C++核心模块进行下层的操作。

从JavaScript调用Node的核心模块，核心模块调用C++内建模块，内建模块通过libuv进行系统调用，这是Node里经典的调用方法。这里libuv作为封装层，有两个平台的实现，实质上是调用了uv_fs_open()方法。在uuv_fs_open()的调用过程，我们创建了一个FSReqWrap请求对象。从JavaScript层传入的参数和当前方法都被封装在这个请求对象中，其中我们最为关注的回调函数则被设置在这个对象的oncomplete_sym属性上：
```
req_wrap->object_->set(oncomplete_sym, callback);
```
对象包装完毕后，在Windows下，则调用QueueUserWorkItem()方法将这个FSReqWrap请求对象推入线程池中等待执行，该方法的代码如下所示。
```
QueueUserWorkItem(&uv_fs_thread_proc, req, WT_EXECUTEDEFAULT);
```
QueueUserWorkItem()方法接受3个参数：第一个参数是将要执行的方法的引用，这里引用的是uv_fs_thread_proc，第二个参数是uv_fs_thread_proc方法运行时所需要的参数；第三个参数是执行的标志。当线程池中有可用线程时，我们会调用uv_fs_thread_proc()方法。uv_fs_thread_proc()方法会根据传入参数的类型调用相应的底层函数。以uv_fs_open()为例，实际上调用fs__open()方法。

至此，JavaScript调用立即返回，由JavaScript层面发起的异步调用的第一阶段就此结束。JavaScript线程可以继续执行当前任务的后续操作。当前的I/O操作在线程池中等待执行，不管他是否阻塞I/O，都不会影响JavaScript线程的后续执行，如此就达到了异步的目的。

请求对象是异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理。

### 执行回调
组装好请求对象、送入I/O池等待执行，实际上完成了异步I/O的第一部分，回调通知是第二部分。

线程池中I/O操作调用完毕之后，会将获取的结果储存在req->request属性上，然后调用PostQueuedCompletionStatus()通知IOCP，告知当前对象已经操作完成:
```
PostQueueCompletionStatus((loop)->iocp,o,o,&((req)->overlapped))
```
PostQueuedCompletionStatus()方法的作用是向IOCP提交执行状态，并将线程归还线程池。通过PostQueuedCompletionStatus提交的状态，可以通过GetQueueCompletionStatus()提取。

在这个过程中，我们其实还调用了事件循环的I/O观察者。在每次Tick的执行中，它会调用IOCP相关的GetQueueCompletionStatus()方法检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到I/O观察者的队列中，然后将其当做事件处理。

I/O观察者回调函数的行为就是取出请求对象的request属性作为参数，取出oncomplete_sym属性作为方法，然后执行调用，以此达到调用JavaScript中传入的回调函数的目的。

事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。

Windows下主要通过IOCP来向系统内核发送I/O调用和从内核获取已完成的I/O操作，配以事件循环，以此完成异步I/O的过程。在Linux下通过epoll实现这个过程，FreeBSD下通过kqueue是吸纳，Solaris下通过Event ports实现。不同的是线程池在Windows下由内核(IOCP)直接提供，*nux系列下由libuv自行实现。
### 小结
从前面实现异步I/O的过程描述中，我们可以提取出异步I/O的几个关键词：单线程、事件循环、观察者和I/O线程池。这里单线程和I/O线程池之间看起来有些悖论的样子。由于我们知道JavaScript是单线程的，所以按常识很容易理解为它不能充分利用多核CPU。事实上，在Node中，除了JavaScript是单线程外，Node自身其实是多线程的，只是I/O线程使用CPU较少。另一个需要重视的观点就是，除了用户代码无法并行执行外，所有的I/O（磁盘I/O和网络I/O等）则是可以并行起来的。
## 非I/O的异步Api
与I/O无关的异步Api，分别是setTimeout()/setInterval()/setImmediate()/process.nextTick()。
### 定时器
setTimeout和setInterval与浏览器中的Api是一致的，分别用于单次和多次定时执行执行任务。它们实现原理与异步I/O比较类似，只是不需要I/O线程池的参与。调用setTimeout()或者setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数将立即执行。

定时器的问题在于，他并非精确的。尽管事件循环十分快，但是如果某一次循环占用的时间比较多，那么下次循环时，也许已经超时很久了。譬如通过setTimeout()设定一个任务在10毫秒后执行，但是在9毫秒后，有一个任务占用了5毫秒的CPU时间片，再次轮到定时器执行时，时间就已经过期4毫秒。
### process.nextTick()
在未了解process.nextTick()之前，很多人也许为了立即异步执行一个任务，会调用setTimeout来到到所需的效果
```
setTimeout(functiom () {
    // TODO
}, 0);
```
由于事件循环自身的特点，定时器的精确度不够。而事实上，采用定时器需要动用红黑树，创建定时器对象和迭代等操作，而setTimeout(fn, 0)的方式较为浪费性能。实际上，process.nextTick()方法的操作相对较为轻量。nextTick具体实现代码为
```
process.nextTick = function (callback) {
  if (process._exiting) {
    return;
  }
  if (tickDepth >= process.maxTickDepth()) {
    maxTickWran();
  }
  var tock = {
    callback
  }
  if(process.domain) {
    tock.domain = process.domain;
  }
  nextTickQueue.push(tock);
  if (nextTickQueue.length) {
    process._needTickCallback();
  }
}
```
每次调用process.nextTick()方法，只会将回调函数放入队列中，在下一轮Tick时取出执行。定时器中采用红黑树的操作时间复杂度为O(lg(n)),nextTick()时间复杂度为O(1)。相较之下process.nextTick()更高效。
### setImmediate()
setImmediate()方法与process.nextTick()方法十分类似，都是将回调函数延迟执行。方法执行方法见test_setImmediate.js

但是两者之间其实是有细微差别的。将他们放在一起查看优先级，请看代码pk_first.js

从结果我们可以看到，process.nextTick()中的回调函数执行的优先级要高于setImmediate()。这里的原因在于事件循环对观察者是有先后顺序的，process.nextTick()属于idle观察者，setImmediate()属于check观察者。在每一个轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者。

再具体实现上，process.nextTick()的回调函数保存在一个数组中，setImmediate()结果则是保存在链表中。在行为上，process.nextTick()在每轮循环中会将数组中的回调函数全部执行完，而setImmediate()在每轮循环中执行链表中的一个回调函数，请看pk_second.js

书上说的执行顺序和现在的稍有不同，因为当时是基于0.x.x，现在v6版本的uv__run_check 的机制改了，idle、check、prepare队列都是一次性处理掉当前任务队列中注册的所有回调，这里两个immediate事件回调注册到了check队列中，显然会被uv__run_check依次执行掉，等check队列执行结束后，才会执行在setImmediate回调执行中注册的process.nextTick函数回调。

### 事件驱动与高性能服务器
异步I/O不仅仅应用在文件操作中。对于网络套接字的处理，Node也应用到了异步I/O，网络套接字上侦听到的请求都会形成事件交给I/O观察者。事件循环会不停地处理这些网路I/O事件。如果JavaScript有传入回调函数，这些事件将会最终传递到业务逻辑层进行处理。利用Node构建Web服务器，正是再这样一个基础上实现的。

下面为几种经典的服务器模型，这里对比下他们的优缺点。
- 同步式。对于同步式的服务，一次只能处理一个请求，并且其余请求都处于等待状态。
- 每进程/每请求。为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多。
- 每线程/每请求。为每个请求启动一个线程来处理。尽管线程比进程要轻量，但是由于每个线程都占用一定内存，当大量并发请求到来时，内存将很快用光，导致服务器缓慢。没线程/没请求 的扩展性比 没进程/没请求 的方式要好，但对于大型站点而言依然不够。

Node通过事件驱动的方式处理请求，无需为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程比较少，上下文切换的代价很低。这使得服务器能够有条不紊的处理请求，即使在大量连接的情况下，也不受线程上下文切换开销的影响，这是Node高性能的一个原因。
## 小结
可以看出，事件循环是异步实现的核心，它与浏览器中的执行模型保持了一致。而像古老的Rhino，尽管是较早就能在服务器端运行的JavaScript运行时，但是执行模型并不能像浏览器采用事件驱动，而是像其他语言一般采用同步I/O作为主要模型，这造成它在性能上无所发挥。Node正是依靠构建了一套完善的高性能异步I/O框架，打破了JavaScript在服务器端止步不前的局面。